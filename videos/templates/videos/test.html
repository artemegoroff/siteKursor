{% extends "baseBoot4.html" %}
{% load staticfiles %}

{% block seo_block %}
{% endblock %}



{% block extracss %}
    {#    <link rel="stylesheet/less" href="{% static 'videos/css/allThemes.less' %}" type="text/less">#}
    <link href="https://fonts.googleapis.com/css?family=Lora" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/css/prism.css' %}">
    <script src="{% static 'js/prism.js' %}"></script>
    <style>
        table td {
            vertical-align: middle !important;
        }
    </style>
{% endblock %}

{% block content %}

    <div class="container" style="margin-top: 100px">

        <h4>Рекурсия в Python</h4>
        <p>Взгляните на картинки ниже и вы поймете, что уже встречались с рекурсией в реальной жизни.</p>
        <p>В программировании под рекурсией понимается такая функция, которая вызывает саму себя.</p>

        <p>Но если вы напишите функцию,которая будет вызывать саму себя бесконечное количество раз, получите
        ошибку Recursionerror: maximum recursion depth exceeded. Попробуйте запустисть у себя на компьютере следующую программу.</p>


        <pre class="line-numbers"><code class=" language-python">def rec(x):
    print(x)
    rec(x+1)

rec(1)</code></pre>
        <p>Поэтому для того, чтобы написать рекурсивную функцию, у вас должно быть условие выхода. То условие, от
        выполнения которого будет зависить, нужно ли вызывать функцию вновь. Попробуйте запустить программу ниже.</p>

        <pre class="line-numbers"><code class=" language-python">def rec(x):
    if x<4:
        print(x)
        rec(x+1)
        print(x)

rec(1)</code></pre>
        <p>Условие выхода называют также базовым случаем - самым простым решением какой-нибудь задачи.</p>

        <h5>Нахождение факториала с помощью рекурсии</h5>

        <p>Например, базовым случаем (самым простым случаем) нахождения факториала, является 1! или 0!. Это значение
        гораздо легче найти, чем например 7! (факториал 7).</p>

        <p>Но рекурсии кроме базового случая должен присутствовать рекурсивный случай или шаг рекурсии - это способ
        сведения задачи к более простой. Например, 5! = 1*2*3*4*5 = 4!*5. То есть, чтобы найти факториал пяти, достаточно
        знать факториал четырех и умножить это на 5. Тогда в общем виде рекурентная формалу нахождения факториала будет
        выглядеть следующим образом:</p>

        <p>А код реализации будет следующим:</p>

        <pre class="line-numbers"><code class=" language-python">def fact(x):
    if x == 1 or x == 0:
        return 1
    return fact(x - 1) * x

a = int(input())
print(fact(a))</code></pre>

        <h5>Нахождение чисел Фибоначчи</h5>
        <p>Числа Фибоначчи представляют собой рекурентный ряд чисел - это значит, что в этом ряду должны
        быть обязательно первые члены ряда (обычно это 0 и 1), а все остальные числа находятся от предыдущих путем
        сложения двух чисел стоящих перед текущим.</p>
        <p>В итоге получаем такой ряд: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 и т.д.</p>
        <p>У каждого числа в этом ряду есть свой порядковый номер, начинается нумерация с единицы. И давайте
            обозначим за F(n) - n-ое число Фибоначчи. И тогда,чтобы найти пятое число Фибоначчи нужно сложить два
            предыдущих к нему F(5) = F(4)+F(4). А общая формула нахождения будет выглядеть следующим образом:
        </p>

        <p>Ниже приведена реализация этой формулы в Python. Более подробно о том, как реализован этот алгоритм,
        смотрите в видео.</p>

        <h5>Проверить строку на палиндром(рекурсия)</h5>
        <p>Палиндром - слово или фраза, которые одинаково читаются слева направо и справа налево.</p>
        <p>Строка, состоящая из одного символа, по умолчанию является палиндромом. Это наш базовый или самый простой
        случай. Также за палиндром мы будет принимать и пустую строку.</p>
        <p>А для всех остальных строк мы будет брать первый и последний символ, если они совпадают, то рекурсивно
        будет проверять строку без этих символов, а в противном случае строка не является палиндромом. </p>
        <p>Ниже представлена рекурсивная функция, которая реализует проверку на палиндром.</p>
        <pre class="line-numbers"><code class=" language-python">def palindrom(s):
    if len(s) <= 1:
        return True
    if s[0] != s[-1]:
        return False
    return palindrom(s[1:-1])

a = input()
print(palindrom(a))</code></pre>


        <h4>Кортежи (tuple)</h4>
        <p>Кортеж (tuple) — упорядоченная коллекция элементов. </p>
        <p>Кортежи очень похожи со спискама(list), за исключением следующих свойств: </p>

        <ul class="list-group list-group-flush">
            <li class="list-group-item">Кортежи определяются путем включения элементов в
                круглые скобки "()" в отличии от списков, где элементы заключаются внутри
                квадратных скобок "[]";</li>
            <li class="list-group-item">Кортежи <b>неизменяемы</b>.</li>
        </ul>


        <h5>Создание кортежа</h5>
        <p>Первый способ - перечислить внутри круглых скобок элементы через запятую </p>
        <pre class="line-numbers"><code class=" language-python">>>> a = (1, True, 'hello', 5)
>>> a
(1, True, 'hello', 5)
>>> type(a)
<сlass 'tuple'> </code></pre>

        <p>Второй способ создания это перечисление нескольких элементов через запятую без скобок. В таком
            случае все равно создаться кортеж.
        </p>

        <pre class="line-numbers"><code class=" language-python">>>> a = 1,True,'hello',5
>>> a
(1, True, 'hello', 5)</code></pre>

        <p> Кортеж получится даже если вы укажите один элемент, но после него поставите запятую</p>

        <pre class="line-numbers"><code class=" language-python">>>> a = 1,
>>> a
(1,)</code></pre>

        <p>Но если вы поставите один элемент без запятой или внутри скобок, это уже будет не кортеж.
        </p>

        <pre class="line-numbers"><code class=" language-python">>>> a = 1
>>> a
1
>>> b = (5)
>>> b
5</code></pre>

        <p>Также кортеж можно создать при помощи функции <b>tuple()</b> и передать ей итерируемый объект.
        </p>

        <pre class="line-numbers"><code class=" language-python">>>> a = tuple([1,2,3])
>>> a
(1, 2, 3)
>>> b = tuple(range(4))
>>> b
(0, 1, 2, 3)
>>> c = tuple('hello')
>>> c
('h', 'e', 'l', 'l', 'o')
>>> d = tuple(1)
Traceback (most recent call last):
  File "<pyshell#19>", line 1, in <module>
    d = tuple(1)
TypeError: 'int' object is not iterable</code></pre>

        <p>В последнем примере мы передавили в функцию <b>tuple()</b> целое числа, и из-за того что оно не являются
            итерируемой последовательностью возникла ошибка.
        </p>

        <p>Для создания пустого кортежа нужно поставить пару пустых круглых скобок или вызвать
            функцию <b>tuple()</b> без параметров:
        </p>

        <pre class="line-numbers"><code class=" language-python"> >>> a = ()
>>> a
()
>>> b = tuple()
>>> b
()</code></pre>

        <h5>Операции над кортежами</h5>

        <h6>Нахождение длины</h6>

        <pre class="line-numbers"><code class=" language-python">>>> a = (1, 2, 3)
>>> len(a)
3
>>> len(())
0</code></pre>

        <h6>Сложение (спецление) кортежей</h6>

        <pre class="line-numbers"><code class=" language-python">>>> a = (1, 2, 3)
>>> b = (4, 5)
>>> a+b
(1, 2, 3, 4, 5)
>>> b+a
(4, 5, 1, 2, 3)</code></pre>

        <h6>Дублирование кортежа</h6>

        <pre class="line-numbers"><code class=" language-python">>>> a = (1, 2, 3)
>>> a*2
(1, 2, 3, 1, 2, 3)</code></pre>

        <h6>Нахождение <u>max()</u> и <u>min()</u></h6>
        <p>Кортеж должен состоять из однотипных элементов</p>

        <pre class="line-numbers"><code class=" language-python">>>> a = (21, 32, 9, 10, 30)
>>> min(a)
9
>>> max(a)
32</code></pre>

         <h6>Применение функции <u>sum()</u></h6>

        <pre class="line-numbers"><code class=" language-python">>>> a = (21, 32, 9, 10, 30)
>>> sum(a)</code></pre>

        <h6>Проверка вхождения элемента в кортеж</h6>

        <pre class="line-numbers"><code class=" language-python">>>> a = (1, 2, 3)
>>> 2 in a
True
>>> 5 in a
False
>>> 4 not in a
True</code></pre>

        <h6>Обращение по индексу кортежа</h6>

        <pre class="line-numbers"><code class=" language-python">>>> a = (1, True, 'hello', 55)
>>> a[1]
True
>>> a[3]
55
>>> a[-2]
'hello'</code></pre>

       <h6>Срезы индексов кортежа</h6>

        <pre class="line-numbers"><code class=" language-python">>>> a = (10, 20, 5, 8, 15, 35)
>>> a[1:3]
(20, 5)
>>> a[2:5]
(5, 8, 15)</code></pre>

    <h5>Кортеж - неизменяемый объект</h5>
    <p>Элементы кортежа нельзя изменять. При попытке сделать такое изменение выскачит исключение TypeError.</p>
        <pre class="line-numbers"><code class=" language-python">>>> a = (1, True, 'hello', 55)
>>> a[3]=100
Traceback (most recent call last):
  File "<pyshell#53>", line 1, in <module>
    a[3]=100
TypeError: 'tuple' object does not support item assignment</code></pre>

     <h5>Методы кортежа</h5>
        <h6>Метод .index(value[, start[,finish]])</h6>
    <p>Данный метод принимает обязательный параметр <b>value</b> и возвращает индекс первого элемента слева
    с таким значением. С помощью необязательных параметров start и finish можно ограничить индексы поиска.
    В случае если в кортеже нет значения вызывается исключение ValueError.</p>
        <pre class="line-numbers"><code class=" language-python">>>> a = (1, 2, 3, 1, 5)
>>> a.index(1)
0
>>> a.index(1,2)
3
>>> a.index(4)
Traceback (most recent call last):
  File "<pyshell#59>", line 1, in <module>
    a.index(4)
ValueError: tuple.index(x): x not in tuple</code></pre>

    <h6>Метод .count(value)</h6>
    <p>Данный метод принимает обязательный параметр <b>value</b> и возвращает количество раз появления
    значения value  в кортеже</p>
        <pre class="line-numbers"><code class=" language-python">>>> a
(1, 2, 3, 1, 5)
>>> a.count(1)
2
>>> a.count(4)
0</code></pre>

    <h5>Обход элементов кортежа в цикле for</h5>

    <p>Обход по значениям элементов</p>
    <pre class="line-numbers"><code class=" language-python">>>> a = (1, True, 'hello', 55)
>>> for i in a:
	print(i)

1
True
hello
55</code></pre>

    <p>Обход по индексам элементов кортежа</p>
    <pre class="line-numbers"><code class=" language-python">>>> a = (1, True, 'hello', 55)
>>> for i in range(len(a)):
	print(a[i])

1
True
hello
55</code></pre>


    </div>
{% endblock %}