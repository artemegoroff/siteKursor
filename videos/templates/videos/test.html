{% extends "baseBoot4.html" %}
{% load staticfiles %}

{% block seo_block %}
{% endblock %}



{% block extracss %}
    {#    <link rel="stylesheet/less" href="{% static 'videos/css/allThemes.less' %}" type="text/less">#}
    <link href="https://fonts.googleapis.com/css?family=Lora" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/css/prism.css' %}">
    <script src="{% static 'js/prism.js' %}"></script>
    <style>
        table td {
            vertical-align: middle !important;
        }
    </style>
{% endblock %}

{% block content %}

    <div class="container" style="margin-top: 100px">


        <h4>Функция enumerate</h4>

        <p>Функция enumerate помогает обойти итерируемые коллекции с возможностью одновременно получать индекс элемента
            и значение.</p>
        <p>Функция enumerate возвращает итератор, который можно легко преобразовать например к списку.</p>


        <iframe src="https://trinket.io/embed/python3/6029d91cde" width="100%" height="180" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>


        <p>В последнем print() мы видим, что функция enumerate возвращает кортежи из пары значений, на первом месте пары
            находится индекс элемента, на втором -
            значение. И результат функции enumerate легко можно обойти в цикле for.</p>

        <iframe src="https://trinket.io/embed/python3/3b9bed5783" width="100%" height="180" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <p>И так как enumerate вовзращает пару значений, вы можете сразу внутри цикла for завести две переменные - index
            и value.</p>

        <iframe src="https://trinket.io/embed/python3/149c054de3" width="100%" height="180" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>



        <p>При помощи генератора списка считываем несколько чисел через пробел в одну строку и превращаем это в
            список</p>
        <iframe src="https://trinket.io/embed/python3/fc7896340a" width="100%" height="150" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <p>С помощью генератора списка легко можно заполнить квадратную матрицу нулями или другим значением.</p>
        <iframe src="https://trinket.io/embed/python3/d3de7fde56" width="100%" height="200" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>


        <p>Генераторы списков также поддерживают возможность организации вложенных циклов</p>
        <iframe src="https://trinket.io/embed/python3/3ad1fb3ab9" width="100%" height="150" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <p>Еще в генераторах списков можно записывать условия</p>
        <iframe src="https://trinket.io/embed/python3/6dac002504" width="100%" height="150" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>


        <iframe src="https://trinket.io/embed/python3/13ceacdbe8" width="100%" height="250" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <p>В примере выше мы видим, что в переменной s после вызова функции genf() содержится именно генератор. Из
            предыдущего занятия мы знаем, что
            <b>генератор</b> - это <b>итератор</b>, элементы которого можно итерировать(обходить поэлементно) только
            один раз. К
            итераторам можно вызывать функцию next()
            и при каждом новом вызове функция-генератор будем генерировать новый элемент из своей коллекции. </p>


        <p>В отличие от обычных функций, которые возвращают значение и завершают работу, функции-генераторы
            автоматически приостанавливают(замораживают) и возобновляют свое выполнение, при этом сохраняя информацию,
            необходимую для
            генерации следующих значений. </p>

        <p> При заморозке Функции-генераторы автоматически сохраняют информацию о своем состоянии и в том числе все
            локальные переменные, которые становятся доступны
            сразу же после того, как функция возобновляет свою работу. </p>

        <iframe src="https://trinket.io/embed/python3/4590841404" width="100%" height="250" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <p>Главное отличие функций-генераторов от обычных функций состоит в том, что функция-генератор передает по
            одному
            значению, а не возвращает целиком сразу весь результат и завершает работу. Инструкция <b>yield</b>
            приостанавливает
            работу функции
            и передает значение вызывающей программе, при этом сохраняется информация о состоянии функции, необходимая,
            чтобы потом вновь
            возобновить работу с места остановки. Когда
            функция-генератор возобновляет работу, ее выполнение продолжается с первой инструкции, следующей за
            инструкцией <b>yield</b>. </p>


        <p>В примере ниже обычная функция fact(n) возвращает при помощи <b>return</b> список факториалов от 1 до n. При
            этом
            для хранения этого
            списка выделяется память.</p>

        <iframe src="https://trinket.io/embed/python3/2afdea1586" width="100%" height="250" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <p> Но мы можем переписать этот код и сделать функцию-генератор. Она будет предоставлять нам значения одно
            значение по требованию и при
            этом помнить накопленный ранее результат. При таком варианте написания мы съэкономим память, отказавшись от
            использования списка.</p>

        <iframe src="https://trinket.io/embed/python3/05226f5c7f" width="100%" height="250" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>


        <ul class="list-group list-group-flush">
            <li class="list-group-item">1 Имя переменной (идентификатор)
            </li>
            <li class="list-group-item">2 Значение переменной
            </li>
            <li class="list-group-item">3 Тип переменной (тип объекта, который хранится в переменной)
            </li>
        </ul>

        <br>
        <h5>Имя переменной</h5>
        <p>Существует ряд правил, которых следует придерживаться при выборе имени переменной.</p>

        <ul class="list-group list-group-flush">
            <li class="list-group-item">Имена переменных не могут содержать пробелов
            </li>
            <li class="list-group-item">Имена переменных могут состоять только из букв, цифр и нижнего подчёркивания
            </li>
            <li class="list-group-item">Регистр символов имеет значение
            </li>
            <li class="list-group-item">Имя переменной не может начинаться с цифры
            </li>
            <li class="list-group-item">Нельзя использовать ключевые слова
            </li>
        </ul>

        <br>

        <h5>Переменная - ссылка на объект</h5>

        <p>Перед тем, как обращаться к содержимому переменной, необходимо сперва создать переменную, присвоив ей
            значение.
            В примере ниже мы обращаемся к несоздаенной переменной b и получаем ошибку <b>NameError</b></p>

        <iframe src="https://trinket.io/embed/python3/b17c3e5725" width="100%" height="180" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <p>Переменная (то есть имя или индификатор как например имя а в примере выше), создается автоматически, когда в
            программе ей впервые
            присваивается некоторое значение. Все последующие операции присваивания просто изменяют значение,
            ассоциированное с уже созданным именем.</p>

        <p>Переменные не имеют никакой информации о типе или ограничениях, связанных с ним. Понятие типа присуще
            объектам, а не именам. Переменные являются всего лишь ссылками на
            конкретные объекты в определенные моменты времени. </p>

        <p>Когда переменную используют в выражении, вместо ее имени подставляется объект, на который она в настоящий
            момент
            ссылается, независимо от того, что это за объект.</p>


        <h5>Тип значения определяет объект, а не переменная</h5>
        <p>Для проверки типа значения используется функция type(). Если ей передать переменную, она покажет к какому
            типу данных
            относится объект, на который ссылается переменная.</p>

        <iframe src="https://trinket.io/embed/python3/9b4953b3ee" width="100%" height="200" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <h5>Оператор присваивания</h5>

        <p>Левая часть = Правая часть</p>
        <p>Оператор присваивания обозначается знаком равно "=". При это он сперва вычисляет значение, стоящее в правой
            части, и сохраняет в
            переменную, находящуюся в левой. Если в левой части стоит переменная, которая не существовала до этого
            момента, она создается. Если
            переменная в левой части существовала, в нее сохранится ссылка на новое значение</p>

        <iframe src="https://trinket.io/embed/python3/0bd0341138" width="100%" height="356" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>

        <h4 class="text-center"> Вопросы для проверки пройденного:</h4>
        <ol class="list-group">
            <li class="list-group-item">
                <p>1 Почему следующая программа не работает?</p>
                <pre class=" language-python"><code class=" language-python">C=777
print(c)</code></pre>
            </li>
            <li class="list-group-item">
                <p>2 Почему эта программа не работает?</p>
                <pre class=" language-python"><code class=" language-python">a=10
print(a,b)
b=20</code></pre>
            </li>
        </ol>


        <p> Но вы также в праве изменить это значение.</p>

        <iframe src="https://trinket.io/embed/python3/b26101839b" width="100%" height="200" frameborder="0"
                marginwidth="0" marginheight="0" allowfullscreen></iframe>


        <pre><code class=" language-python">>>> d=int(input())
123
>>> type(d)
class 'int'
>>> d+2
125</code></pre>
        <p>Оборачивая <b>input()</b> функцией <b>int()</b>, мы преобразуем введеную строку в целое число. Но будьте
            аккуратны!
            Если пользователь введет символы, которые нельзя преобразовать к целому числу, получите ошибку
            <b>ValueError</b>.</p>


        <pre><code class=" language-python">d=int(input())
15sdf4
Traceback (most recent call last):
    d=int(input())
ValueError: invalid literal for int() with base 10: '15sdf4'</code></pre>

        <p>Если вам необходимо ввести вещественное число и сохранить его в переменную q, необходимо
            обернуть функцию <b>input()</b> в функцию <b>float()</b></p>

        <pre><code class=" language-python">>>> q=float(input())
4.5
>>> q
4.5
>>> type(q)
class 'float'</code></pre>


        <h5> Заключение</h5>
        <p>Варианты использования функции <b>input()</b></p>
        <ul class="list-group list-group-flush">
            <li class="list-group-item"><b>a = input()</b> - если необходимо ввести строку и сохранить ее в переменную а
            </li>
            <li class="list-group-item"><b>a = int(input())</b> - если необходимо ввести целое число и сохранить его в
                переменную а
            </li>
            <li class="list-group-item"><b>a = float(input())</b> - если необходимо ввести вещественное число и
                сохранить его в переменную а
            </li>
        </ul>


    </div>
{% endblock %}